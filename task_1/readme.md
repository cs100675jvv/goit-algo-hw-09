Результат для набору монет [50, 25, 10, 5, 2, 1] та суми 113:
Greedy algorithm result: {50: 2, 10: 1, 2: 1, 1: 1}
Greedy algorithm execution time: 0.0000000000000000 seconds
Dynamic programming result: {50: 2, 10: 1, 2: 1, 1: 1}
Dynamic programming execution time: 0.0000000000000000 seconds

Результат для набору монет [50, 25, 10, 5, 2, 1] та суми 11334987:
Greedy algorithm result: {50: 226699, 25: 1, 10: 1, 2: 1}
Greedy algorithm execution time: 0.0000000000000000 seconds
Dynamic programming result: {50: 226699, 25: 1, 10: 1, 2: 1}
Dynamic programming execution time: 9.6224179267883301 seconds

Як бачимо, при такому наборі монет результат однаковий, але при великій кількості монет жадібний агоритм працює набагато швидше, а динамічне програмування може працювати досить повільно при великих сумах.

Результат для набору монет [10, 6, 1] та суми 1112:
Greedy algorithm result: {10: 111, 1: 2}
Greedy algorithm execution time: 0.0000000000000000 seconds
Dynamic programming result: {10: 110, 6: 2}
Dynamic programming execution time: 0.0009651184082031 seconds

При такому наборі монет жадібний алгоритм вже дає неоптимальний результат, хоч і значно швидше.

Висновок:
жадібний алгоритм зазвичай набагато швидший для великих сум, але не завжди може давати оптимальне рішення для довільних наборів монет. Підхід динамічного програмування забезпечує оптимальне рішення, але може бути повільнішим через більш складні обчислення.